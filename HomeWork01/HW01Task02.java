package HomeWork01;

public class HW01Task02 {
    public static void main(String[] args) {
        int a = 2;
        int b = 8;
        int intResult = 0;          // переменная для целочисленного результата выражений
        boolean boolResult = false; // переменная для логического (булевого) результата выражений

        /* 2.1. Деление выполняется первым, т.к. оно целочисленное то получаем в результате 0 (2/8 = 0).
        Далее выполняется сложение 5 + 0 = 5. */
        intResult = 5 + 2 / 8; // 5
        System.out.println("2.1. " + intResult);

        /* 2.2. Сложение выполняется первым, т.к. оно находится в скобках. Получаем 5 + 2 = 7.
        Далее выполняется целочисленное деление 7 / 8 = 0. */
        intResult = (5 + 2) / 8; // 0
        System.out.println("2.2. " + intResult);

        /* 2.3. Поскольку a++ это постинкремент, то в сложении будет участвовать значение переменной a = 2
        (до её увеличения на единицу), т. е. имеем (5 + 2) = 7. Далее идёт целочисленное деление 7 / 8 = 0. */
        intResult = (5 + a++) / 8; // 0
        System.out.println("2.3. " + intResult);

        /* 2.4. Поскольку a++ это постинкремент, то в сложении будет участвовать значение переменной a = 2
        (до её увеличения на единицу), т. е. имеем (5 + 2) = 7. Т.к. --b это предекремент, то сначала происходит
        уменьшение на единицу, а затем присваивание переменной b нового значения (7). Далее имеем целочисленное
        деление 7 / 7 = 1. */
        a = 2;
        intResult = (5 + a++) / --b; // 1
        System.out.println("2.4. " + intResult);

        /* 2.5. Т.к. в скобках у нас постинкремент, то для сдвига вправо будет использоваться a равное 2, т.е. до
        увеличения на единицу. Получаем 5 * 2 = 10, а 10 в двоичном формате имеет вид 1010. После сдвига вправо на 2
        разряда получаем двоичное число 10, что эквивалентно 2 в десятичной системе счисления. --b это предекремент,
        поэтому сначала переменная b уменьшится на единицу, а затем её новое значение (7) будет присвоено переменной b,
        а далее использовано в делении. Получаем целочисленное деление 2 / 7 = 0. */
        a = 2;
        b = 8;
        intResult = (5 * 2 >> a++) / --b; // 0
        System.out.println("2.5. " + intResult);

        /* 2.6. Сначала вычисляем выражение в скобках. Сначала умножение 22 * 2 = 44. Далее сложение 5 + 7 = 12.
        Теперь сдвиг вправо. 44 в двоичной системе имеет вид 101100, а т.к. a++ это постинкремент, то сдвиг вправо
        происходит на 2 разряда (т.е. до увеличения переменной a на единицу). Получаем двоичное число 1011, что в
        десятичной системе равно 11. Теперь выполняем тернарный оператор, который получил следующий вид
        (12 > 20 ? 68 : 11) - т.к. 12 меньше 20, то результатом будет 11. Далее выполняется операция предекремента --b
        и мы получаем 7. В итоге имее целочисленное деление 11 / 7 = 1. */
        a = 2;
        b = 8;
        intResult = (5 + 7 > 20 ? 68 : 22 * 2 >> a++) / --b; // 1
        System.out.println("2.6. " + intResult);

        /* 2.7. Данное выражение не будет скомпилировано. Для того что бы возможно было осуществить целочислонное
        деление, выражение в скобках (делимое) должно быть целым числом. В нашем случае в скобках находится тернарный
        оператор, который при любых случаях должен возвращать целое число. Но в первом случае возвращает логическое
        значение: 68 >= 68 => true, к которому невозможно применить операцию целочисленного деления. */
        a = 2;
        b = 8;
        //intResult = (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> a++) / --b; // java: bad operand types for binary operator '/'
        System.out.println("2.7. " + "ERROR!");

        /* 2.8. Сначала будет выполнено умножение 12 * 12 = 144. Далее выполняется вычитание 6 - 2 = 4. Далее
        выполняется следующая операция сравнения: 144 <= 119, результатом которой будет false. Далее выполняется
        следующая операция сравнения: 4 > 3, результатом которой будет true. В итоге получаем следующую логическую
        операцию true && false, результатом которой будет false. */
        boolResult = 6 - 2 > 3 && 12 * 12 <= 119; // false
        System.out.println("2.8. " + boolResult);

        /* 2.9. Логический оператор && работет по короткой схеме. В данном случае значение первого операнда равно true
        и поэтому оператор смотрит значение второго операнда, который равен false. Т.о. результат всего выражения
        также получается false. */
        boolResult = true && false; // false
        System.out.println("2.9. " + boolResult);

    }
}